<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Join Conference</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            background: #000;
        }

        .videos {
            display: grid;
            width: 100vw;
            height: 100vh;

            gap: 8px;
            padding: 8px;
            box-sizing: border-box;

            transition:
                    grid-template-columns 300ms ease,
                    grid-template-rows 300ms ease;
        }

        /* видео */
        .video {
            position: relative;
            width: 100%;
            height: 100%;
            background: black;

            overflow: hidden;
            border-radius: 6px;

            transform: scale(1);
            transition:
                    transform 250ms ease,
                    opacity 250ms ease;
        }

        .video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* появление */
        .video.enter {
            opacity: 0;
            transform: scale(0.95);
        }

        .video.enter-active {
            opacity: 1;
            transform: scale(1);
        }

    </style>
</head>
<body>

<div id="videos" class="grid"></div>

<script>
    const roomId = "room1"
    const peerId = crypto.randomUUID();

    let pendingCandidates = [];

    const videos = document.getElementById('videos');

    const ws = new WebSocket("ws://localhost:8080/ws")
    const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    })

    pc.oniceconnectionstatechange = () => {
        console.log('ICE connection state:', pc.iceConnectionState);
    }

    pc.ontrack = (event) => {
        const stream = event.streams[0];
        console.log('ontrack event:', {
            trackKind: event.track.kind,
            trackId: event.track.id,
            streamId: stream?.id,
            myPeerId: peerId,
            isMyStream: stream?.id === peerId
        });

        if (!stream) return;

        console.log('creating video for remote stream:', stream.id);
        createVideoElement(stream);
    }

    pc.onicecandidate = (event) => {
        if (!event.candidate) return

        ws.send(JSON.stringify({
            type: "candidate",
            roomId: roomId,
            memberId: peerId,
            candidate: event.candidate
        }))
    }

    pc.onnegotiationneeded = (event) => {
        console.log("negotiationneeded event:", event);
    }

    ws.onmessage = async (event) => {
        console.log(event.data)
        const msg = JSON.parse(event.data);

        switch (msg.type) {
            case "answer":
                console.log('received answer from server');
                await pc.setRemoteDescription({
                    type: "answer",
                    sdp: msg.sdp
                });

                for (const c of pendingCandidates) {
                    try {
                        await pc.addIceCandidate(c);
                    } catch (e) {
                        console.warn('failed to add queued candidate', e);
                    }
                }
                pendingCandidates = [];

                break;
            case "offer":
                await pc.setRemoteDescription({
                    type: "offer",
                    sdp: msg.sdp
                })

                const answer = await pc.createAnswer()

                await pc.setLocalDescription(answer)

                ws.send(JSON.stringify({
                    type: "answer",
                    roomId: roomId,
                    memberId: peerId,
                    sdp: pc.localDescription.sdp
                }));
                break;
            case "candidate":
                const cand = msg.candidate;
                if (!pc.remoteDescription) {
                    pendingCandidates.push(cand);
                    return;
                }
                try {
                    await pc.addIceCandidate(cand);
                } catch (e) {
                    console.warn('failed to add candidate', e);
                }
                break;

        }
    }

    (async () => {
        await initLocalMedia();
        await negotiate(ws);
    })();

    async function initLocalMedia() {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false
        });

        createVideoElement(stream, true);

        stream.getTracks().forEach(track => {
            pc.addTrack(track, stream);
        });
    }

    async function negotiate(ws) {
        console.log('creating offer with peerId:', peerId);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        console.log('sending offer to server');
        ws.send(JSON.stringify({
            type: "offer",
            roomId: roomId,
            memberId: peerId,
            sdp: offer.sdp
        }));

        console.log('negotiation complete');
    }

    async function renegotiate(offer) {
        await pc.setRemoteDescription({
            type: "offer",
            sdp: offer
        })

        const answer = await pc.createAnswer()

        await pc.setLocalDescription(answer)

        return pc.localDescription
    }

    function createVideoElement(stream, muted = false) {
        const video = document.createElement('video');
        video.id = `video-${stream.id}`;
        video.srcObject = stream;
        video.autoplay = true;
        video.playsInline = true;
        video.muted = muted;

        videos.appendChild(video);
        updateLayout();8
    }
</script>

<script>
    const container = document.getElementById('videos')

    function updateLayout() {
        const count = container.children.length

        if (count === 1) {
            container.style.gridTemplateColumns = '1fr'
            container.style.gridTemplateRows = '1fr'
            return
        }

        if (count === 2) {
            container.style.gridTemplateColumns = '1fr 1fr'
            container.style.gridTemplateRows = '1fr'
            return
        }

        if (count <= 4) {
            container.style.gridTemplateColumns = '1fr 1fr'
            container.style.gridTemplateRows = '1fr 1fr'
            return
        }

        // дальше авто-сетка
        container.style.gridTemplateColumns =
            'repeat(auto-fill, minmax(300px, 1fr))'
        container.style.gridAutoRows = '1fr'
    }

    function addVideo(stream) {
        const wrapper = document.createElement('div')
        wrapper.className = 'video enter'

        const video = document.createElement('video')
        video.autoplay = true
        video.playsInline = true
        video.srcObject = stream

        wrapper.appendChild(video)
        container.appendChild(wrapper)

        // триггер анимации
        requestAnimationFrame(() => {
            wrapper.classList.remove('enter')
            wrapper.classList.add('enter-active')
        })

        updateLayout()
    }

    function removeVideo(index) {
        const el = container.children[index]
        if (!el) return

        el.style.opacity = '0'
        el.style.transform = 'scale(0.95)'

        setTimeout(() => {
            el.remove()
            updateLayout()
        }, 250)
    }
</script>

</body>
</html>
